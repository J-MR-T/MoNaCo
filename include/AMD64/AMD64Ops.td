#ifndef AMD64OPS
#define AMD64OPS

include "AMD64/AMD64Dialect.td"

include "mlir/IR/AttrTypeBase.td"

include "mlir/IR/OpBase.td"

include "mlir/IR/BuiltinTypes.td"
// don't include this: "mlir/IR/BuiltinOps.td". Breaks everything for some reason
include "mlir/IR/BuiltinAttributes.td"
include "mlir/IR/BuiltinDialect.td"

include "mlir/IR/BuiltinTypeInterfaces.td"
include "mlir/IR/FunctionInterfaces.td"
include "mlir/IR/SymbolInterfaces.td"

include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
// my interfaces
include "AMD64/InstructionOpInterface.td"

include "mlir/IR/EnumAttr.td"

// TODO add op traits, like commutative, to the ops

// TODO see if this works, when its autogenerated
//include "fadec-encode-public.td"

// === types ===

/*  TEST, TODO remove later

def Case1: I64EnumAttrCase<"Case1", 0x55aaff>;

def MyIntEnum : I64EnumAttr<"MyIntEnum", "example", [Case1]>{
  let cppNamespace = "::amd64";
  let stringToSymbolFnName = "ConvertToEnum";
  let symbolToStringFnName = "ConvertToString";
}

*/

// base type
class AMD64_Type<string name, string typeMnemonic, int bitwidth, list<Trait> traits = []>
    : TypeDef<AMD64_Dialect, name, traits> {
  let mnemonic = typeMnemonic;
  let extraClassDeclaration = "static constexpr int getBitWidth() { return " # bitwidth # "; };"; // declaration should be right, because it's inline
}

class AMD64_GPR_Type<string name, int bitwidth, string typeMnemonic = name, list<Trait> traits = []>
    : AMD64_Type<name, typeMnemonic, bitwidth, traits> {
  
}

// GP types

foreach bitwidth = [8, 16, 32, 64] in {
  def gpr#bitwidth : AMD64_GPR_Type<"gpr"#bitwidth, bitwidth>;
}

// === traits ===

class Operand1IsDestN<int N>
  : ParamNativeOpTrait<"Operand1IsDestN", !cast<string>(N)>;

// TODO replace with property
class OperandNIsConstrainedToReg<int N, string reg>
  : ParamNativeOpTrait<"OperandNIsConstrainedToReg", !cast<string>(N) # "," # reg>;

// === memory op ===
// TODO

// === properties ===

// this is heavily based on mlir/test/lib/Dialect/Test/TestOps.td/cpp/h
// TODO property test, move to a proper (haha) place
def InstructionInfoProp : Property<"InstructionInfo"> {
  let convertToAttribute = "$_storage.asAttribute($_ctxt)";
  let convertFromAttribute = "return InstructionInfo::setFromAttr($_storage, $_attr, $_diag);";
  let hashProperty = "$_storage.hash();";
}

// === ops (= instructions) ===


// use the InstructionOpInterface to inject generic functionality into all instructions
class Instruction<string mnemonic, list<Trait> traits = []> :
  AMD64_Op<mnemonic, !listconcat(traits,[InstructionOpInterface])> {

  let extraClassDeclaration = "static constexpr FeMnem getFeMnemonic() { return FE_" # mnemonic # "; }" /* declaration, because getFeMnemonic is inline */ #
    "InstructionInfo& instructionInfo();";

  let extraClassDefinition = "InstructionInfo& $cppClass::instructionInfo() { return this->getProperties().instructionInfoImpl; }";

  dag operands = ?;
  // TODO I would prefer the concatenation in the order regs # operands, but that inhibits default values for regs, which is annoying
  // TODO can hopefully be eliminated with properties later on anyway, please?
  let arguments = !con(operands, (ins InstructionInfoProp:$instructionInfoImpl));
}

def CMP8rr : Instruction<"CMP8rr">{
  let operands = (ins gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}

/*
def MUL8r : Instruction<"MUL8r", [Operand1IsDestN<1>, OperandNIsConstrainedToReg<1, "FE_AX">]>{
  let operands = (ins gpr8:$src1, gpr8:$src2); // src1 is always Dest 1, and always AX
  let results = (outs gpr8:$dst);
}
*/

multiclass Instr_rmi<string mnemonic, AMD64_GPR_Type result, AMD64_GPR_Type op1, AMD64_GPR_Type op2, list<Trait> traits = []> {

  // TODO because these require different ops, this will be transformed from a foreach into 5 separate defs later on. Can use smth like `let results = (outs result:$dst) in {...}` for the 3 with r as dst op tho
  foreach suffix = ["rr", "rm", "mr", "ri", "mi"] in {
    def suffix : Instruction<mnemonic # suffix, traits>{
      let operands = (ins op1:$src1, op2:$src2);
      let results = (outs result:$dst);
    }
  }

  /*
     the foreach above basically produces:

  def rr : Instruction<mnemonic # "rr", traits>{
    let operands = (ins op1:$src1, op2:$src2);
    let results = (outs result:$dst);
  }
  def rm : Instruction<mnemonic # "rm", traits>{...}
  def mr ...
  def ri ...
  def mi ...

  */
}

multiclass Instr8_16_32_64_rmi<string mnemonic, list<Trait> traits = []> {

  foreach suffix = ["8", "16", "32", "64"] in {
    defvar gprType = !cast<AMD64_GPR_Type>("gpr"#suffix);
    defm suffix : Instr_rmi<mnemonic#suffix, gprType, gprType, gprType, traits>;
  }

  /* this foreach is the same as:
    defm "8" : Instr_rmi<mnemonic# "8",  gpr8,  gpr8,  gpr8,  traits>;
    defm "16": Instr_rmi<mnemonic# "16", gpr16, gpr16, gpr16, traits>;
    defm "32": Instr_rmi<mnemonic# "32", gpr32, gpr32, gpr32, traits>;
    defm "64": Instr_rmi<mnemonic# "64", gpr64, gpr64, gpr64, traits>;
  */
}

/* ways to define an instr:

// manually:
 
def ADD8rr : Instruction<"ADD8rr"> {
  let operands = (ins gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}

// for a specified bitwidth:

defm ADD8 : Instr_rmi<"ADD8", gpr8, gpr8, gpr8>;

// for all bitwidths:

defm ADD : Instr8_16_32_64_rmi<"ADD">;

*/

defm ADD : Instr8_16_32_64_rmi<"ADD">;

// TODO remove as soon as the generic one works
def MOV8ri : Instruction<"MOV8ri"> {
  let operands = (ins Property<"int8_t">:$imm);
  let results = (outs gpr8:$dst);
}

foreach bitwidth = ["8", "16", "32", "64"] in {
  defvar gprType = !cast<AMD64_GPR_Type>("gpr"#bitwidth);

  let results = (outs gprType:$dst) in {
    def MUL # bitwidth # "r" : Instruction<"MUL" # bitwidth # "r", [Operand1IsDestN<1>, OperandNIsConstrainedToReg<1, "FE_AX">]>{
      let operands = (ins gprType:$src1, gprType:$src2);
    }

    def MUL # bitwidth # "m": Instruction<"MUL" # bitwidth # "m", [Operand1IsDestN<1>, OperandNIsConstrainedToReg<1, "FE_AX">]>{
      let operands = (ins gprType:$src1, gprType:$src2); // TODO the second one needs to be a memory operand, as soon as those exist
    }

/*
    def MOV # bitwidth # "ri" : Instruction<"MOV" # bitwidth # "ri", []>{
      let operands = (ins Property<"int" # bitwidth # "_t">:$imm); // only ODSSupport.h only supports int64_t currently, so this uses custom definitions for convertTo/FromAttribute, defined in AMD64Ops.cpp

      // no builders generated which can set a property, so we need to do it manually
      let builders = [
        OpBuilder<(ins "int" # bitwidth # "_t":$immArg), [{
          build($_builder, $_state);
          mlir::dyn_cast<}] # /* $cppClass doesn't work :( */ "amd64::MOV" # bitwidth # "ri" # [{>($_builder.getInsertionPoint()).getProperties().setImm(immArg);
        }]>
      ];
    }
  */
  }
}


/*
def ADD8rr : Instruction<"add8rr"> {
  let operands = (ins FeMnem:$mnemonic, gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}
*/

/*
an extensive and still totally incomplete list of problems
- how to generate all the necessary possible ops, without too much code duplication
  - multiclasses, lets, and defms probably
- how to use fadec symbols here? e.g. FE_ADD8rr (0x30600000000000), how to include this in these definitions, also automatically, without having to map it all out by hand
  - possibly needs a conversion to some kind of tablegen enum, if something like that exists
    - yes that exists and doesn't work, because it generates too much automatically :(
  - 
- 
*/

// example for 8 bit adds

/*
def ADD8rr : AMD64_Base_Op<"add8rr"> {
  let mnemonic = "add";
  let operands = (ins AMD64_i8:$src1, AMD64_i8:$src2);
  let results = (outs AMD64_i8:$dst);

  let fe_mnemonic = 0x30600000000000;
}
*/

#endif
