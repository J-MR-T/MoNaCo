#ifndef AMD64OPS
#define AMD64OPS

include "AMD64/AMD64Dialect.td"

include "mlir/IR/AttrTypeBase.td"

include "mlir/IR/OpBase.td"

include "mlir/IR/BuiltinTypes.td"
// don't include this: "mlir/IR/BuiltinOps.td". Breaks everything for some reason
include "mlir/IR/BuiltinAttributes.td"
include "mlir/IR/BuiltinDialect.td"

include "mlir/IR/BuiltinTypeInterfaces.td"
include "mlir/IR/FunctionInterfaces.td"
include "mlir/IR/SymbolInterfaces.td"

include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
// my interfaces
include "AMD64/InstructionOpInterface.td"

include "mlir/IR/EnumAttr.td"

// TODO add op traits, like commutative, to the ops

// TODO see if this works, when its autogenerated
//include "fadec-encode-public.td"

// === types ===

/*  TEST, TODO remove later

def Case1: I64EnumAttrCase<"Case1", 0x55aaff>;

def MyIntEnum : I64EnumAttr<"MyIntEnum", "example", [Case1]>{
  let cppNamespace = "::amd64";
  let stringToSymbolFnName = "ConvertToEnum";
  let symbolToStringFnName = "ConvertToString";
}
*/

// base type
class AMD64_Type<string name, string typeMnemonic, int bitwidth, list<Trait> traits = []>
    : TypeDef<AMD64_Dialect, name, traits> {
  let mnemonic = typeMnemonic;
  let extraClassDeclaration = "static constexpr int getBitWidth() { return " # bitwidth # "; };"; // declaration should be right, because it's inline
}

class AMD64_GPR_Type<string name, int bitwidth, string typeMnemonic = name, list<Trait> traits = []>
    : AMD64_Type<name, typeMnemonic, bitwidth, traits> {
  
}

// GP types

foreach bitwidth = [8, 16, 32, 64] in {
  def gpr#bitwidth : AMD64_GPR_Type<"gpr"#bitwidth, bitwidth>;
}

// === ops (= instructions) ===

// use the InstructionOpInterface to inject generic functionality into all instructions
class Instruction<string mnemonic, list<Trait> traits = []> :
  AMD64_Op<mnemonic, !listconcat(traits,[InstructionOpInterface])> {

  let extraClassDeclaration = "static constexpr uint64_t getFeMnemonic() { return FE_" # mnemonic # "; }"; // declaration, because it's inline
}

multiclass Instr_rmi<string mnemonic, AMD64_GPR_Type result, AMD64_GPR_Type op1, AMD64_GPR_Type op2, list<Trait> traits = []> {

  foreach suffix = ["rr", "rm", "mr", "ri", "mi"] in {
    def suffix : Instruction<mnemonic # suffix, traits>{
      let arguments = (ins op1:$src1, op2:$src2);
      let results = (outs result:$dst);
    }
  }

  /*
     the foreach above basically produces:

  def rr : Instruction<mnemonic # "rr", traits>{
    let arguments = (ins op1:$src1, op2:$src2);
    let results = (outs result:$dst);
  }
  def rm : Instruction<mnemonic # "rm", traits>{...}
  def mr ...
  def ri ...
  def mi ...

  */
}

multiclass Instr8_16_32_64_rmi<string mnemonic, list<Trait> traits = []> {
  // TODO figure out if its possible to also do this with a foreach
  defm "8" : Instr_rmi<mnemonic# "8",  gpr8,  gpr8,  gpr8,  traits>;
  defm "16": Instr_rmi<mnemonic# "16", gpr16, gpr16, gpr16, traits>;
  defm "32": Instr_rmi<mnemonic# "32", gpr32, gpr32, gpr32, traits>;
  defm "64": Instr_rmi<mnemonic# "64", gpr64, gpr64, gpr64, traits>;
}

/* ways to define an instr:

// manually:
 
def ADD8rr : Instruction<"ADD8rr"> {
  let arguments = (ins gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}

// for a specified bitwidth:

defm ADD8 : Instr_rmi<"ADD8", gpr8, gpr8, gpr8>;

// for all bitwidths:

defm ADD : Instr8_16_32_64_rmi<"ADD">;

*/

defm ADD : Instr8_16_32_64_rmi<"ADD">;

def MOV8ri : Instruction<"MOV8ri"> {
  let arguments = (ins I8Attr:$imm);
  let results = (outs gpr8:$dst);
}

/*
def ADD8rr : Instruction<"add8rr"> {
  let arguments = (ins FeMnem:$mnemonic, gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}
*/

/*
an extensive and still totally incomplete list of problems
- how to generate all the necessary possible ops, without too much code duplication
  - multiclasses, lets, and defms probably
- how to use fadec symbols here? e.g. FE_ADD8rr (0x30600000000000), how to include this in these definitions, also automatically, without having to map it all out by hand
  - possibly needs a conversion to some kind of tablegen enum, if something like that exists
    - yes that exists and doesn't work, because it generates too much automatically :(
  - 
- 
*/

// example for 8 bit adds

/*
def ADD8rr : AMD64_Base_Op<"add8rr"> {
  let mnemonic = "add";
  let operands = (ins AMD64_i8:$src1, AMD64_i8:$src2);
  let results = (outs AMD64_i8:$dst);

  let fe_mnemonic = 0x30600000000000;
}
*/

#endif
