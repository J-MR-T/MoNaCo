#ifndef AMD64OPS
#define AMD64OPS

include "AMD64/AMD64Dialect.td"

include "mlir/IR/AttrTypeBase.td"

include "mlir/IR/OpBase.td"

include "mlir/IR/BuiltinTypes.td"
// don't include this: "mlir/IR/BuiltinOps.td". Breaks everything for some reason
include "mlir/IR/BuiltinAttributes.td"
include "mlir/IR/BuiltinDialect.td"

include "mlir/IR/BuiltinTypeInterfaces.td"
include "mlir/IR/FunctionInterfaces.td"
include "mlir/IR/SymbolInterfaces.td"

include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
// my interfaces
include "AMD64/InstructionOpInterface.td"

include "mlir/IR/EnumAttr.td"

// TODO add op traits, like commutative, to the ops

// TODO see if this works, when its autogenerated
//include "fadec-encode-public.td"

// === types ===

/*  TEST, TODO remove later

def Case1: I64EnumAttrCase<"Case1", 0x55aaff>;

def MyIntEnum : I64EnumAttr<"MyIntEnum", "example", [Case1]>{
  let cppNamespace = "::amd64";
  let stringToSymbolFnName = "ConvertToEnum";
  let symbolToStringFnName = "ConvertToString";
}

*/

// base type
class AMD64_Type<string name, string typeMnemonic, int bitwidth, list<Trait> traits = []>
    : TypeDef<AMD64_Dialect, name, traits> {
  let mnemonic = typeMnemonic;
  let extraClassDeclaration = "static constexpr int getBitWidth() { return " # bitwidth # "; };"; // declaration should be right, because it's inline
}

class AMD64_GPR_Type<string name, int bitwidth, string typeMnemonic = name, list<Trait> traits = []>
    : AMD64_Type<name, typeMnemonic, bitwidth, traits> {
  
}

// GP types

foreach bitwidth = [8, 16, 32, 64] in {
  def gpr#bitwidth : AMD64_GPR_Type<"gpr"#bitwidth, bitwidth>;
}

// === traits ===

class Operand1IsDestN<int N>
  : ParamNativeOpTrait<"Operand1IsDestN", !cast<string>(N)>;

class OperandNIsConstrainedToReg<int N, string reg>
  : ParamNativeOpTrait<"OperandNIsConstrainedToReg", !cast<string>(N) # "," # reg>;

// === ops (= instructions) ===

// use the InstructionOpInterface to inject generic functionality into all instructions
class Instruction<string mnemonic, list<Trait> traits = []> :
  AMD64_Op<mnemonic, !listconcat(traits,[InstructionOpInterface])> {

  let extraClassDeclaration = "static constexpr FeMnem getFeMnemonic() { return FE_" # mnemonic # "; }" /* declaration, because getFeMnemonic is inline */;

  dag operands = ?;
  let arguments = !con((ins DefaultValuedAttr<I32Attr, "0">:$regs), operands); // in this order, such that operands are just accessed through 1 based indexing, and regs can always be accessed at exactly op 0
}

/*
def MUL8r : Instruction<"MUL8r", [Operand1IsDestN<1>, OperandNIsConstrainedToReg<1, "FE_AX">]>{
  let operands = (ins gpr8:$src1, gpr8:$src2); // src1 is always Dest 1, and always AX
  let results = (outs gpr8:$dst);
}
*/

multiclass Instr_rmi<string mnemonic, AMD64_GPR_Type result, AMD64_GPR_Type op1, AMD64_GPR_Type op2, list<Trait> traits = []> {

  // TODO because these require different ops, this will be transformed from a foreach into 5 separate defs later on. Can use smth like `let results = (outs result:$dst) in {...}` for the 3 with r as dst op tho
  foreach suffix = ["rr", "rm", "mr", "ri", "mi"] in {
    def suffix : Instruction<mnemonic # suffix, traits>{
      let operands = (ins op1:$src1, op2:$src2);
      let results = (outs result:$dst);
    }
  }

  /*
     the foreach above basically produces:

  def rr : Instruction<mnemonic # "rr", traits>{
    let operands = (ins op1:$src1, op2:$src2);
    let results = (outs result:$dst);
  }
  def rm : Instruction<mnemonic # "rm", traits>{...}
  def mr ...
  def ri ...
  def mi ...

  */
}

multiclass Instr8_16_32_64_rmi<string mnemonic, list<Trait> traits = []> {

  foreach suffix = ["8", "16", "32", "64"] in {
    defvar gprType = !cast<AMD64_GPR_Type>("gpr"#suffix);
    defm suffix : Instr_rmi<mnemonic#suffix, gprType, gprType, gprType, traits>;
  }

  /* this foreach is the same as:
    defm "8" : Instr_rmi<mnemonic# "8",  gpr8,  gpr8,  gpr8,  traits>;
    defm "16": Instr_rmi<mnemonic# "16", gpr16, gpr16, gpr16, traits>;
    defm "32": Instr_rmi<mnemonic# "32", gpr32, gpr32, gpr32, traits>;
    defm "64": Instr_rmi<mnemonic# "64", gpr64, gpr64, gpr64, traits>;
  */
}

/* ways to define an instr:

// manually:
 
def ADD8rr : Instruction<"ADD8rr"> {
  let operands = (ins gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}

// for a specified bitwidth:

defm ADD8 : Instr_rmi<"ADD8", gpr8, gpr8, gpr8>;

// for all bitwidths:

defm ADD : Instr8_16_32_64_rmi<"ADD">;

*/

defm ADD : Instr8_16_32_64_rmi<"ADD">;

def MOV8ri : Instruction<"MOV8ri"> {
  let operands = (ins I8Attr:$imm);
  let results = (outs gpr8:$dst);
}

foreach bitwidth = ["8", "16", "32", "64"] in {
  defvar gprType = !cast<AMD64_GPR_Type>("gpr"#bitwidth);

  def MUL # bitwidth # "r" : Instruction<"MUL" # bitwidth # "r", [Operand1IsDestN<1>, OperandNIsConstrainedToReg<1, "FE_AX">]>{
    let operands = (ins gprType:$src1, gprType:$src2);
    let results = (outs gprType:$dst);
  }

  def MUL # bitwidth # "m": Instruction<"MUL" # bitwidth # "m", [Operand1IsDestN<1>, OperandNIsConstrainedToReg<1, "FE_AX">]>{
    let operands = (ins gprType:$src1, gprType:$src2);
    let results = (outs gprType:$dst);
  }
}


/*
def ADD8rr : Instruction<"add8rr"> {
  let operands = (ins FeMnem:$mnemonic, gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}
*/

/*
an extensive and still totally incomplete list of problems
- how to generate all the necessary possible ops, without too much code duplication
  - multiclasses, lets, and defms probably
- how to use fadec symbols here? e.g. FE_ADD8rr (0x30600000000000), how to include this in these definitions, also automatically, without having to map it all out by hand
  - possibly needs a conversion to some kind of tablegen enum, if something like that exists
    - yes that exists and doesn't work, because it generates too much automatically :(
  - 
- 
*/

// example for 8 bit adds

/*
def ADD8rr : AMD64_Base_Op<"add8rr"> {
  let mnemonic = "add";
  let operands = (ins AMD64_i8:$src1, AMD64_i8:$src2);
  let results = (outs AMD64_i8:$dst);

  let fe_mnemonic = 0x30600000000000;
}
*/

#endif
