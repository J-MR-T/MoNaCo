#ifndef AMD64OPS
#define AMD64OPS

include "AMD64/AMD64Dialect.td"

include "mlir/IR/AttrTypeBase.td"

include "mlir/IR/OpBase.td"

include "mlir/IR/BuiltinTypes.td"
// don't include this: "mlir/IR/BuiltinOps.td". Breaks everything for some reason
include "mlir/IR/BuiltinAttributes.td"
include "mlir/IR/BuiltinDialect.td"

include "mlir/IR/BuiltinTypeInterfaces.td"
include "mlir/IR/FunctionInterfaces.td"
include "mlir/IR/SymbolInterfaces.td"

include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
// my interfaces
include "AMD64/InstructionOpInterface.td"
include "AMD64/EncodeOpInterface.td"

include "mlir/IR/EnumAttr.td"

// TODO add op traits, like commutative and pure, to the ops

// TODO see if this works, when its autogenerated
//include "fadec-encode-public.td"

// === types ===

/*  TEST, TODO remove later

def Case1: I64EnumAttrCase<"Case1", 0x55aaff>;

def MyIntEnum : I64EnumAttr<"MyIntEnum", "example", [Case1]>{
  let cppNamespace = "::amd64";
  let stringToSymbolFnName = "ConvertToEnum";
  let symbolToStringFnName = "ConvertToString";
}

*/

// base type
class AMD64_Type<string name, string typeMnemonic, int bitwidth, list<Trait> traits = []>
    : TypeDef<AMD64_Dialect, name, traits> {
  let mnemonic = typeMnemonic;
  let extraClassDeclaration = "static constexpr int getBitWidth() { return " # bitwidth # "; };"; // declaration should be right, because it's inline
}

def memLoc : AMD64_Type<"memLoc", "memloc", 64>;

// to get the register of a value of AMD64_GPR_Type, use `registerOf()`.
class AMD64_GPR_Type<string name, int bitwidth, string typeMnemonic = name, list<Trait> traits = []>
    : AMD64_Type<name, typeMnemonic, bitwidth, traits> {
}

// GP types

foreach bitwidth = [8, 16, 32, 64] in {
  def gpr#bitwidth : AMD64_GPR_Type<"gpr"#bitwidth, bitwidth>;
}

def anygprType: TypeConstraint<Or<[gpr8.predicate, gpr16.predicate, gpr32.predicate, gpr64.predicate]>>;

// === traits ===

// TODO fix everywhere, that this only actually makes sense, if the operand is a register
//      maybe just ignore it during encoding, if it's not a register, that seems easiest
class Operand1IsDestN<int N>
  : ParamNativeOpTrait<"Operand1IsDestN", !cast<string>(N)>;

// TODO replace with static method on op, see AMD64Types.h for details
class OperandNIsConstrainedToReg<int N, string reg>
  : ParamNativeOpTrait<"OperandNIsConstrainedToReg", !cast<string>(N) # "," # reg>;

def HasImm : NativeOpTrait<"HasImm">;

// === memory ops ===
// TODO maybe everything should have the encoding interface? Immediates could also be modeled that way, but might cost performance, because ops are pretty big in comparison to immediates as operands/properties
// TODO create a mem op/encoding interface

class MemOp<string mnemonic, list<Trait> traits = []>: AMD64_Op<mnemonic, !listconcat(traits, [EncodeOpInterface])>{
  code encoding = ?;
  let extraClassDeclaration = [{
    inline FeOp encode() {
      }] # encoding # [{
    }
  }];
}

// TODO for local variables/memref.alloca/llvm.alloca: define a memop-like alloca operation, that gives back a memloc and also implements the encoding interface, it can then be used just as a normal variable

// first memory op, this is the most powerful one, more will follow.
def MemSIBD : MemOp<"MemSIBD">{
  let arguments = (ins anygprType:$base, Property<"uint8_t">:$scale, anygprType:$index, Property<"int64_t">:$displacement);
  let results = (outs memLoc:$memloc);

  let encoding = [{
    return FE_MEM(
      registerOf(mlir::dyn_cast<mlir::OpResult>(getBase())),
      getProperties().scale,
      registerOf(mlir::dyn_cast<mlir::OpResult>(getIndex())),
      getProperties().displacement
    );
  }];

  // custom builder to initialize the properties, this is currently the only way to do it
  let builders = [
    OpBuilder<(ins "::mlir::Value":$base, "uint8_t":$scaleArg, "::mlir::Value":$index, "int64_t":$displacementArg), [{
      auto& prop = $_state.getOrAddProperties<MemSIBD::Properties>();
      prop.scale = scaleArg;
      prop.displacement = displacementArg;
      build($_builder, $_state, base, index);
    }]>
  ];
}

// === properties ===

// this is heavily based on mlir/test/lib/Dialect/Test/TestOps.td|cpp|h
// one big instruction info property, so that the tablegen doesn't have to change, when new info is added
def InstructionInfoProp : Property<"InstructionInfo"> {
  let convertToAttribute = "$_storage.asAttribute($_ctxt)";
  let convertFromAttribute = "return InstructionInfo::setFromAttr($_storage, $_attr, $_diag);";
  let hashProperty = "$_storage.hash();";
}

// === ops (= instructions) ===


// use the InstructionOpInterface to inject generic functionality into all instructions
class Instruction<string mnemonic, list<Trait> traits = []> :
  AMD64_Op<mnemonic, !listconcat(traits,[InstructionOpInterface])> {
  // basically equivalent to arguments, but arguments are conditionally furthered based on traits, and more info, so these here are the 'raw' operands.
  dag operands = ?;

  // this var is currently unused, but are not hurtful either
  // if the instruction has an immediate, it has the HasImm trait
  defvar hasImm = !not(!empty(!filter(trait, traits, !eq(trait, HasImm))));

  let extraClassDeclaration = "static constexpr FeMnem getFeMnemonic() { return FE_" # mnemonic # "; }" /* declaration, because getFeMnemonic is inline */ #
    "InstructionInfo& instructionInfo();";

  let extraClassDefinition = "InstructionInfo& $cppClass::instructionInfo() { return this->getProperties().instructionInfoImpl; }";

  // always append the instruction info property. Immediates are stored in the instruction info
  let arguments = !con(operands, (ins InstructionInfoProp:$instructionInfoImpl));
}

// TODO remove later, replace with generic version
def CMP8rr : Instruction<"CMP8rr">{
  let operands = (ins gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}

/*
def MUL8r : Instruction<"MUL8r", [Operand1IsDestN<1>, OperandNIsConstrainedToReg<1, "FE_AX">]>{
  let operands = (ins gpr8:$src1, gpr8:$src2); // src1 is always Dest 1, and always AX
  let results = (outs gpr8:$dst);
}
*/

// immediate instruction multiclass
multiclass Instr_i<string mnemonic, list<Trait> traits = []> {
  // TODO probably needs custom builder or declaration to initialize the immediate I don't think this is possible generically, as we would have to repeat all possible arguments. Let's hope there is in-tree support for this soon
  def "i" : Instruction<mnemonic # "i", !listconcat(traits, [HasImm])>;
}

let operands = (ins memLoc:$op1), results = (outs) in
defm SUB8m : Instr_i<"SUB8m">;

// produces "rr", "rm", "mr", "mi", "ri" variants
multiclass Instr_rmi<string mnemonic, AMD64_GPR_Type result, AMD64_GPR_Type op1, AMD64_GPR_Type op2, list<Trait> traits = []> {
  let results = (outs) in {
    let operands = (ins memLoc:$src1, op2:$src2) in
    def "mr" : Instruction<mnemonic # "mr", traits>;

    let operands = (ins memLoc:$src1) in
    defm "m" : Instr_i<mnemonic # "m", traits>;
  }

  let results = (outs result: $dst) in {
    let operands = (ins op1:$src1, op2:$src2) in 
    def "rr" : Instruction<mnemonic # "rr", traits>;

    let operands = (ins op1:$src1, memLoc:$src2) in
    def "rm" : Instruction<mnemonic # "rm", traits>;

    let operands = (ins op1:$src1) in
    defm "r" : Instr_i<mnemonic # "r", traits>;
  }

  /*
     this thing above is basically equivalent to this:

  def rr : Instruction<mnemonic # "rr", traits>{
    let operands = (ins op1:$src1, op2:$src2);
    let results = (outs result:$dst);
  }
  def rm : Instruction<mnemonic # "rm", traits>{...}
  def mr ...
  def ri ...
  def mi ...

  */
}

multiclass Instr8_16_32_64_rmi<string mnemonic, list<Trait> traits = []> {

  foreach suffix = ["8", "16", "32", "64"] in {
    defvar gprType = !cast<AMD64_GPR_Type>("gpr"#suffix);
    defm suffix : Instr_rmi<mnemonic#suffix, gprType, gprType, gprType, traits>;
  }

  /* this foreach is the same as:
    defm "8" : Instr_rmi<mnemonic# "8",  gpr8,  gpr8,  gpr8,  traits>;
    defm "16": Instr_rmi<mnemonic# "16", gpr16, gpr16, gpr16, traits>;
    defm "32": Instr_rmi<mnemonic# "32", gpr32, gpr32, gpr32, traits>;
    defm "64": Instr_rmi<mnemonic# "64", gpr64, gpr64, gpr64, traits>;
  */
}

/* ways to define an instr:

// manually:
 
def ADD8rr : Instruction<"ADD8rr"> {
  let operands = (ins gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}

// for a specified bitwidth:

defm ADD8 : Instr_rmi<"ADD8", gpr8, gpr8, gpr8>;

// for all bitwidths:

defm ADD : Instr8_16_32_64_rmi<"ADD">;

*/

defm ADD : Instr8_16_32_64_rmi<"ADD", [Operand1IsDestN<1>]>;

// miscellaneous 'special' instructions
foreach bitwidth = ["8", "16", "32", "64"] in {
  defvar gprType = !cast<AMD64_GPR_Type>("gpr"#bitwidth);


  // zero result instructions
  let results = (outs) in {
    def MUL # bitwidth # "m": Instruction<"MUL" # bitwidth # "m", [Operand1IsDestN<1>, OperandNIsConstrainedToReg<1, "FE_AX">]>{
      let operands = (ins gprType:$src1, memLoc:$src2);
    }
  }

  // one result instructions
  let results = (outs gprType:$dst) in {
    def MUL # bitwidth # "r" : Instruction<"MUL" # bitwidth # "r", [Operand1IsDestN<1>, OperandNIsConstrainedToReg<1, "FE_AX">]>{
      let operands = (ins gprType:$src1, gprType:$src2);
    }

    def MOV # bitwidth # "ri" : Instruction<"MOV" # bitwidth # "ri", [Pure, HasImm]> {
      let operands = (ins);

      // currently native properties don't get a generated builder to set their value upon op building, so we do that ourselves. Sadly this is very hard to do for any immediate op (because we need to replicate all args), so for now it only works on MOVs
      let builders = [
        OpBuilder<(ins "int" # bitwidth # "_t":$immArg), [{
          $_state.getOrAddProperties<InstructionInfo>().imm = immArg;
          build($_builder, $_state);
        }]>
      ];
    }

  }
}


/*
def ADD8rr : Instruction<"add8rr"> {
  let operands = (ins FeMnem:$mnemonic, gpr8:$src1, gpr8:$src2);
  let results = (outs gpr8:$dst);
}
*/

/*
an extensive and still totally incomplete list of problems
- how to generate all the necessary possible ops, without too much code duplication
  - multiclasses, lets, and defms probably
- how to use fadec symbols here? e.g. FE_ADD8rr (0x30600000000000), how to include this in these definitions, also automatically, without having to map it all out by hand
  - possibly needs a conversion to some kind of tablegen enum, if something like that exists
    - yes that exists and doesn't work, because it generates too much automatically :(
  - 
- 
*/

// example for 8 bit adds

/*
def ADD8rr : AMD64_Base_Op<"add8rr"> {
  let mnemonic = "add";
  let operands = (ins AMD64_i8:$src1, AMD64_i8:$src2);
  let results = (outs AMD64_i8:$dst);

  let fe_mnemonic = 0x30600000000000;
}
*/

#endif
